package com.ufgov.zc.client.component.zc.dataexchange.model;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.FileReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.io.PrintWriter;import java.nio.charset.Charset;import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Calendar;import java.util.Date;import java.util.HashMap;import java.util.Iterator;import java.util.List;import java.util.Map;import com.thoughtworks.xstream.XStream;import com.thoughtworks.xstream.io.xml.DomDriver;import com.ufgov.zc.client.common.Zip;import com.ufgov.zc.common.system.constants.ZcSettingConstants;import com.ufgov.zc.common.system.exception.BusinessException;import com.ufgov.zc.common.zc.model.DataExchange;public class CommonDataExchangeOperator {  public final static String suffix = "_UFIDA_COMPO";  /**   * 保存所有需要导出的数据到文件中   * @param list   */  public static boolean prepareDataForExport(Map<String, IBaseData> dataMap, Map<String, DataExchange> compoMap, String topDir) {    if (dataMap == null || dataMap.size() == 0)      return false;    fileDirCreator(topDir, null);    String cursor = null;    Iterator<String> it = dataMap.keySet().iterator();    while (it.hasNext()) {      cursor = it.next();      if (cursor == null)        continue;      DataExchange de = compoMap.get(cursor);      if (de == null)        continue;      //为了导入时读取的方面，特别在每个部件名目录加上统一的后缀suffix      String currDir = fileDirCreator(topDir, de.getDataTypeName() + suffix);      File currFile = new File(currDir + File.separator + de.getDataTypeID());      if (!currFile.exists()) {        try {          currFile.createNewFile();        } catch (IOException e) {          e.printStackTrace();          return false;        }      }      saveObjectToFile(dataMap.get(cursor), currFile.getAbsolutePath());    }    return true;  }  /**   * 检查当前路径的对应的目录是否存在，如果不存在就创建   * @param path   * @param subPath   * @return   */  private static String fileDirCreator(String path, String subPath) {    String fullPath = path;    if (subPath != null && !"".equals(subPath)) {      fullPath = path + File.separator + subPath;    }    File currDir = new File(fullPath);    if (!currDir.exists()) {      currDir.mkdirs();    }    return currDir.getAbsolutePath();  }  /**   * 将数据串行化到文件中   * @param data   * @param dir   */  private static void saveObjectToFile(IBaseData data, String fileName) {    try {      ObjectSerialize.outPutSerialize(data, fileName);    } catch (Exception e) {      e.printStackTrace();    }  }  /**   * 将数据xml到文件中   * @param data   * @param dir   */  public static void saveObjectToXmlFile(IBaseData data, String fileName) {    XStream xs = new XStream(new MyXppDriver());    FileOutputStream fos = null;    OutputStreamWriter writer = null;    try {      CommonDataExchangeOperator.makeDirs(fileName);      fos = new FileOutputStream(fileName);      writer = new OutputStreamWriter(fos, Charset.forName("UTF-8"));      //xml文件头必须手工加上         writer.write("<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n");      xs.toXML(data, writer);      writer.close();    } catch (FileNotFoundException e) {      e.printStackTrace();    } catch (IOException e) {      e.printStackTrace();    } finally {      if (writer != null) {        try {          writer.close();          fos.close();        } catch (IOException e) {          e.printStackTrace();        }      }    }  }  /**   * 创建需要的目录，如果path中的父目录尚未创建，那么也将自动创建   * @param path   */  protected static void makeDirs(String path) {    File file = new File(path).getParentFile();    if (!file.exists()) {      file.mkdirs();    }  }  /**   * 读取压缩包，并根据解压开后的文件目录结构返回所有串行化文件的路径   * @param zipFilePath   * @param importDataList   * @param inFlag   */  public static void prepareDataForImport(String zipFilePath, List<IBaseData> importDataList) {    String rootDir = readZipPackage(zipFilePath);    Map<String, List<String>> map = new HashMap<String, List<String>>();    List<String> subDirs = new ArrayList<String>();    map.put("component_dirs", subDirs);    List<String> serFiles = new ArrayList<String>();    map.put("ser_files", serFiles);    List<String> attachmentFiles = new ArrayList<String>();    map.put("attachmentFiles", attachmentFiles);    getSubDirectories(rootDir, map);    if (importDataList == null)      importDataList = new ArrayList<IBaseData>();    for (int i = 0; i < serFiles.size(); i++) {      IBaseData ibd = null;      readFileToObject(ibd, serFiles.get(i));      importDataList.add(ibd);    }    System.out.print("haha:" + importDataList.size());  }  /**   * 必须返回解压后的总目录，目录下包含了所有的部件目录的目录即是总目录，也作为根目录,   * 标准的目录结构应该是：最底一级包含着对象串行化的文件和相关的所有附件，如下图   *                             总  目  录(1级目录)   *       -------------------------------------------------------------   *         |(部件A)      |(部件B)       |(部件C)      |...   | (2级目录)   *       ------------  -------------  ------------  --------------------------------   *       |.ser |.jpg |...   |.ser |.jpg |...   |.ser |.jpg |...(2级目录下的各种文件)        *                * @param zipFilePath   * @return   */  private static String readZipPackage(String zipFilePath) {    if (zipFilePath == null || !zipFilePath.endsWith(".zip"))      return zipFilePath + "";    String rootDir = zipFilePath.substring(0, zipFilePath.indexOf("."));    try {      Zip zip = new Zip();      zip.unzip(zipFilePath, rootDir);    } catch (Exception e) {      e.printStackTrace();    }    return rootDir;  }  /**   * 获取所有.ser文件所在的路径   * @param root   * @returnc   */  private static void getSubDirectories(String root, Map<String, List<String>> map) {    File[] files = new File(root).listFiles();    for (int i = 0; i < files.length; i++) {      if (files[i].isDirectory()) {        if (files[i].getName().endsWith(suffix)) {          map.get("component_dirs").add(files[i].getAbsolutePath());        } else {          getSubDirectories(files[i].getAbsolutePath(), map);        }      } else {        if (files[i].getName().endsWith(".ser")) {          map.get("ser_files").add(files[i].getAbsolutePath());        } else {          map.get("attachment_files").add(files[i].getAbsolutePath());        }      }    }  }  /**   * 读取串行化文件中的数据，并还原成对象实例   * @param data   * @param dir   */  private static void readFileToObject(IBaseData data, String fileName) {    try {      data = null;      data = (IBaseData) ObjectSerialize.inPutSerialize(data, fileName);    } catch (Exception e) {      e.printStackTrace();    }  }  /**   * 读取xml文件中的数据，并还原成对象实例   * @param data   * @param dir   */  public static IBaseData readXmlFileToObject(IBaseData data, String fileName) {    XStream xs = new XStream(new DomDriver());    FileInputStream fis = null;    InputStreamReader input = null;    try {      fileName = prepareToStandardXml(fileName);      fis = new FileInputStream(fileName);      //为了防止乱码，指定文件输出的编码格式         input = new InputStreamReader(fis, Charset.forName("UTF-8"));      data = null;      data = (IBaseData) xs.fromXML(input);      input.close();      return data;    } catch (Exception e) {      e.printStackTrace();      throw new BusinessException("xml文件反转成对象时出错...",e);    } finally {      if (input != null) {        try {          input.close();          fis.close();        } catch (IOException e) {          e.printStackTrace();        }      }    }  }  /**   * 读取xml文件里面的内容写一个新文件   * @param fileName   * @return   */  public static String prepareToStandardXml(String fileName) {    File file = new File(fileName);    try {      BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(file), ZcSettingConstants.UTF8));      String line;      while ((line = reader.readLine()) != null) {        line = stripNonValidXMLChars(line);      }      reader.close();    } catch (Exception e) {      e.printStackTrace();    }    return fileName;  }  public static String stripNonValidXMLChars(String str) {    if (str == null || "".equals(str)) {      return str;    }    str = str.replaceAll("\\u000B", "");    str = str.replaceAll("\\u000C", "");    str = str.replaceAll("\\u000A", "");    str = str.replaceAll("\\u000D", "");    str = str.replaceAll("\\u000b", "");    str = str.replaceAll("\\u0009", "");    return str.replaceAll(" [\\x00-\\x08\\x0b-\\x0c\\x0e-\\x1f] ", "");  }  /**   * 递归删除整个目录及目录下的文件   * @param rootPath   */  public static void deleteFiles(String rootPath) {    //为了安全起见，不允许删除盘符直接作为根目录指令    if (rootPath == null || (rootPath.indexOf(":") == 1 && rootPath.length() < "C:/".length())) {      return;    }    File file = new File(rootPath);    if (!file.exists()) {      return;    }    if (file.isDirectory()) {      File[] files = file.listFiles();      for (int i = 0; i < files.length; i++) {        if (files[i].isDirectory()) {          deleteFiles(files[i].getAbsolutePath());        } else {          files[i].delete();        }      }      file.delete();    } else {      file.delete();    }  }  /**   * 检查文件路径中是否存在非法字符   * @return   */  public static boolean checkFilePath(String path) {    if (path == null || "".equals(path)) {      return false;    }    return !path.matches("[^\\s\\\\/:\\*\\?\\\"<>\\|](\\x20|[^\\s\\\\/:\\*\\?\\\"<>\\|])*[^\\s\\\\/:\\*\\?\\\"<>\\|\\.]$");  }  /**   * 获取从今天算起的前几天或后几天   * @param days 需要获得前n天时，传入值为-n，需要获得后几天时，则传入n;   */  public static Date getDateFromToday(int days) {    Calendar cal = Calendar.getInstance();    cal.add(Calendar.DATE, days);    return cal.getTime();  }  /**   * 获得指定格式的日期   * @param days   * @return   */  public static String getDateFromToday(int days, String format) {    SimpleDateFormat sfd = new SimpleDateFormat(format);    return sfd.format(getDateFromToday(days));  }  public static void main(String[] args) {    IBaseData instance = null;    instance = CommonDataExchangeOperator.readXmlFileToObject(instance,    "E:\\20110222\\供应商注册_UFIDA_COMPO\\com.ufgov.gk.client.zc.zcebsupplier.ZcEbSupplierDataExchangeExecutor.xml");    System.out.println(instance.getAttachmentDataMap());  }  /**   * 将数据xml到文件中   * @param data   * @param dir   */  public static void saveObjectToXmlFile(Object data, String fileName) {    XStream xs = new XStream(new MyXppDriver());    FileOutputStream fos = null;    OutputStreamWriter writer = null;    try {      CommonDataExchangeOperator.makeDirs(fileName);      fos = new FileOutputStream(fileName);      writer = new OutputStreamWriter(fos, Charset.forName("utf-8"));      //xml文件头必须手工加上         writer.write("<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n");      xs.toXML(data, writer);      writer.close();    } catch (FileNotFoundException e) {      e.printStackTrace();    } catch (IOException e) {      e.printStackTrace();    } finally {      if (writer != null) {        try {          writer.close();          fos.close();        } catch (IOException e) {          e.printStackTrace();        }      }    }  }  /**   * 读取xml文件中的数据，并还原成对象实例   * @param data   * @param dir   */  public static Object readXmlFileToObject(String fileName) {    XStream xs = new XStream(new DomDriver());    FileInputStream fis = null;    InputStreamReader input = null;    try {      fileName = prepareToStandardXml(fileName);      fis = new FileInputStream(fileName);      //为了防止乱码，指定文件输出的编码格式         input = new InputStreamReader(fis, Charset.forName("utf-8"));      Object data = null;      data = xs.fromXML(input);      input.close();      return data;    } catch (Exception e) {      e.printStackTrace();      throw new BusinessException("xml文件反转成对象时出错...");    } finally {      if (input != null) {        try {          input.close();        } catch (IOException e) {          e.printStackTrace();        }      }    }  }}