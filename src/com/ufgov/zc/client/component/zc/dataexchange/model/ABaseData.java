package com.ufgov.zc.client.component.zc.dataexchange.model;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.util.ArrayList;import java.util.Collection;import java.util.HashMap;import java.util.Iterator;import java.util.List;import java.util.Map;import javax.swing.JOptionPane;import com.ufgov.zc.client.common.ServiceFactory;import com.ufgov.zc.client.common.WorkEnv;import com.ufgov.zc.client.component.zc.dataexchange.DataExchangeListPanel;import com.ufgov.zc.client.zc.ztb.fileResumeBroken.download.ResumeBrokenDownloads;import com.ufgov.zc.common.commonbiz.publish.IBaseDataServiceDelegate;import com.ufgov.zc.common.system.MimeMapping;import com.ufgov.zc.common.system.RequestMeta;import com.ufgov.zc.common.system.dto.ElementConditionDto;import com.ufgov.zc.common.system.model.AsFile;import com.ufgov.zc.common.zc.model.DataExchangeRedo;import com.ufgov.zc.common.zc.publish.IDataExchangeServiceDelegate;public abstract class ABaseData implements IBaseData {  private static final long serialVersionUID = 473779409137779129L;  protected String dataTypeID;  protected String dataTypeName;  protected String mainTableName;  //是否运行发送文件到服务器时存在发送失败(丢失)的情况，如果允许失败，那么出现失败或者丢失后将继续后续文件的发生，否则将终止文件发送  protected boolean isAllowFileFail = true;  //需要导入或导出的数据  protected List dataList = null;  //需要导出的数据id哈希表,以dataExchangeRedo.id,Object.id的形式存放  protected transient List<DataExchangeRedo> needExportDataRedoList = new ArrayList<DataExchangeRedo>();  //所有失败的消息，最好以 key:value的形式存储  protected transient List<String> failMsgList = new ArrayList<String>();  //所有成功的消息，以<具体业务model的id:DataExchangeRedo>  protected transient Map<String, DataExchangeRedo> successRecordMap = new HashMap<String, DataExchangeRedo>();  //所有的附件文件  protected Map<String, Map<String, AttachmentFile>> attachmentDataMap;  protected transient ExchangeDataLogModel exchangeDataLogModel = null;  public ExchangeDataLogModel getExchangeDataLogModel() {    if (this.exchangeDataLogModel == null) {      this.exchangeDataLogModel = new ExchangeDataLogModel();    }    return exchangeDataLogModel;  }  private transient IBaseDataServiceDelegate baseDataServiceDelegate = null;  protected IBaseDataServiceDelegate getBaseDataServiceDelegate() {    if (this.baseDataServiceDelegate == null) {      baseDataServiceDelegate = (IBaseDataServiceDelegate) ServiceFactory.create(IBaseDataServiceDelegate.class, "baseDataServiceDelegate");    }    return this.baseDataServiceDelegate;  }  private transient IDataExchangeServiceDelegate dataExchangeServiceDelegate = null;  protected IDataExchangeServiceDelegate getDataExchangeServiceDelegate() {    if (dataExchangeServiceDelegate == null) {      dataExchangeServiceDelegate = (IDataExchangeServiceDelegate) ServiceFactory.create(IDataExchangeServiceDelegate.class,      "dataExchangeServiceDelegate");    }    return dataExchangeServiceDelegate;  }  public Map<String, String> getColumnHeadersMap() {    return new HashMap<String, String>();  }  public String getDataTypeID() {    return dataTypeID;  }  public void setDataTypeID(String dataTypeID) {    this.dataTypeID = dataTypeID;  }  public List getDataList() {        if(dataList==null)dataList=new ArrayList();    return dataList;  }  public String getMainTableName() {    return mainTableName;  }  public String getDataTypeName() {    return dataTypeName;  }  public void setDataTypeName(String dataTypeName) {    this.dataTypeName = dataTypeName;  }  public void setMainTableName(String mainTableName) {    this.mainTableName = mainTableName;  }  public void setDataList(List dataList) {    this.dataList = dataList;  }  public List<DataExchangeRedo> getNeedExportDataRedoList() {    return needExportDataRedoList;  }  public void setNeedExportDataRedoList(Object[] needExportDataRedoList) {    for (int i = 0; i < needExportDataRedoList.length; i++) {      this.needExportDataRedoList.add((DataExchangeRedo) needExportDataRedoList[i]);    }  }  public List<String> getFailMsgList() {    return failMsgList;  }  public void setFailMsgList(List<String> failMsgList) {    this.failMsgList = failMsgList;  }  /**   * 根据记录id获得redo对象   * @param id   * @return   */  protected DataExchangeRedo getDataExchangeRedo(String id) {    DataExchangeRedo redo = null;    for (int i = 0; i < this.needExportDataRedoList.size(); i++) {      redo = this.needExportDataRedoList.get(i);      if (id.equals(redo.getRecordID()) && this.getDataTypeID().equals(redo.getDataTypeID())) {        return redo;      }    }    return null;  }  /**   * 创建需要的目录，如果path中的父目录尚未创建，那么也将自动创建   * @param path   */  protected void makeDirs(String path) {    File file = new File(path);    if (!file.exists()) {      file.mkdirs();    }  }  /**   * 拷贝目录和文件   * @param sourceDir   * @param tarDir   * @param fileID   */  protected void copyDirAndFiles(String sourceDir, String tarDir, String fileID) {    String fileName = "";    makeDirs(tarDir);    File file = new File(sourceDir);    File[] files = file.listFiles();    if (files == null) {      return;    }    for (int i = 0; i < files.length; i++) {      if (files[i].getName().length() < fileID.length()) {        continue;      }      fileName = files[i].getName().substring(0, fileID.length());      if (fileName.equalsIgnoreCase(fileID)) {//只处理对应fileID指定的文件或目录        this.searchSubFiles(files[i], tarDir);      }    }  }  /**   * 递归搜索所有子目录下的文件   * @param file   * @param tarDir   */  protected void searchSubFiles(File file, String tarDir) {    if (file.isDirectory()) {//如果是目录      String newPath = tarDir + File.separator + file.getName();      makeDirs(newPath);      File subFile = new File(file.getAbsolutePath());      File[] subFiles = subFile.listFiles();      for (int si = 0; si < subFiles.length; si++) {        if (subFiles[si].isFile()) {          this.copyFile(subFiles[si], newPath + File.separator + subFiles[si].getName());        } else {          this.searchSubFiles(subFiles[si], newPath);        }      }    } else if (file.isFile()) {//如果是文件      this.copyFile(file, tarDir + File.separator + file.getName());    }  }  /**   * 执行拷贝   * @param source   * @param targetb   */  protected void copyFile(File source, String target) {    FileInputStream fis = null;    FileOutputStream fos = null;    try {      DataExchangeListPanel.setProgressText(this.getDataTypeName() + "正在处理" + source.getName());      fis = new FileInputStream(source);      fos = new FileOutputStream(target);      byte[] buff = new byte[8192];      int i = 0;      while ((i = fis.read(buff)) != -1) {        fos.write(buff, 0, i);      }      fis.close();      fos.close();    } catch (FileNotFoundException e) {      e.printStackTrace();    } catch (IOException e) {      e.printStackTrace();    } finally {      try {        if (fis != null) {          fis.close();        }        if (fos != null) {          fos.close();        }      } catch (Exception e) {        e.printStackTrace();      }    }  }  /**   * 将文件发送到服务器端保存，该方法调试完毕后，需要移到CommonDataExchangeOpertor类下   * @param attFile   * @param meta   * @return   */  protected boolean doSendFiles(AttachmentFile attFile, String rootPath, RequestMeta meta) {    String sourceFileDir = rootPath + File.separator + attFile.getSourceFilePath();    String savePath = attFile.getTargetFilePath();    String fileName = attFile.getFileName();    String fileID = attFile.getFileID();    if ("file".equalsIgnoreCase(attFile.getFileType())) {      if (!this.sendFileToServer(sourceFileDir, savePath, fileName, fileID, meta) && !this.isAllowFileFail) {        return false;      }    } else {      File file = new File(sourceFileDir);      if (!file.exists() && this.isAllowFileFail) {        return false;      }      File[] files = file.listFiles();      for (int i = 0; i < files.length; i++) {        if (files[i].isDirectory() && files[i].getName().indexOf(fileID) >= 0) {          if (!this.sentSubFiles(files[i], sourceFileDir, savePath, fileName, fileID, meta) && !this.isAllowFileFail) {            return false;          }        }      }    }    return true;  }  /**   * 发送目录下的所有文件，如果一个文件发送失败，则终止这次文件发送   * @param file   * @param sourceFileDir   * @param savePath   * @param fileName   * @param fileID   * @param meta   * @param sentRes   * @return   */  protected boolean sentSubFiles(File file, String sourceFileDir, String savePath, String fileName, String fileID, RequestMeta meta) {    File[] subFiles = file.listFiles();    for (int j = 0; j < subFiles.length; j++) {      if (subFiles[j].isFile()) {        sourceFileDir = file.getAbsolutePath();        fileName = subFiles[j].getName();        if (!this.sendFileToServer(sourceFileDir, savePath, fileName, fileID, meta) && !this.isAllowFileFail) {          return false;        }      } else {        sourceFileDir = subFiles[j].getAbsolutePath();        fileName = subFiles[j].getName();        savePath = savePath + "/" + fileName;        if (!sentSubFiles(subFiles[j], sourceFileDir, savePath, fileName, fileID, meta) && !this.isAllowFileFail) {          return false;        }      }    }    return true;  }  /**   * 将文件发送到服务器，并存储在web容器下或者服务器下的文件系统下   * @param sourceFileDir    * @param serverSavePath:服务器端保存位置，如果为null或者""，则   * @param fileName   * @param fileID   * @param meta   * @return 成功返回true，否则返回false   */  protected boolean sendFileToServer(String sourceFileDir, String serverSavePath, String fileName, String fileID, RequestMeta meta) {    File file = new File(sourceFileDir + File.separator + fileName);    if (!file.exists()) {      return true;    }    FileInputStream fis = null;    try {      fis = new FileInputStream(file);      int fileSize = fis.available();      if (!this.checkFileSize(fileSize, fileName)) {        return false;      }      AsFile asFile = new AsFile();      byte[] content = new byte[fis.available()];      fis.read(content);      asFile.setFileId(fileID);      asFile.setFileContent(content);      asFile.setFileName(file.getName());      asFile.setMimeType(MimeMapping.getMimeType(fileName));      DataExchangeListPanel.setProgressText(this.getDataTypeName() + "正在发送文件:" + file.getAbsolutePath());      return this.getBaseDataServiceDelegate().uploadFile(asFile, serverSavePath, fileName, meta);    } catch (Exception e) {      e.printStackTrace();      return false;    } finally {      if (fis != null) {        try {          fis.close();        } catch (IOException e) {          e.printStackTrace();          return false;        }      }    }  }  /**   * 检查文件的大小，文件大小不能超过jvm的可用内存大小   * @param fileSize   * @param fileName   * @return true表示文件大小在允许范围内，否则无法处理   */  private boolean checkFileSize(int fileSize, String fileName) {    int resultSize = fileSize / 1024 / 1024;    long vmMaxMemSize = Runtime.getRuntime().maxMemory() / 1024 / 1024;//M    long vmTotalMemSize = Runtime.getRuntime().totalMemory() / 1024 / 1024;//M    int useableMemSize = (int) (vmMaxMemSize - vmTotalMemSize);    if ((resultSize - useableMemSize) > 5) {      JOptionPane.showMessageDialog(null, "文件" + fileName + "太大,无法处理[" + resultSize + "MB],不能超过[" + (useableMemSize - 20) + "MB].");      return false;    }    return true;  }  /**   * 将文件发送到服务器，存储在数据库AsFile表中   * @param sourceFileDir   * @param fileName   * @param meta   * @return 成功则返回文件的fileID，是一个36位的GUID，全球唯一标识，否则返回""   */  protected String sendFileToServer(String sourceFileDir, String fileName, RequestMeta meta) {    File file = new File(sourceFileDir + File.separator + fileName);    FileInputStream fis = null;    try {      fis = new FileInputStream(file);      int fileSize = fis.available();      if (!this.checkFileSize(fileSize, fileName)) {        return "";      }      AsFile asFile = new AsFile();      byte[] content = new byte[fis.available()];      fis.read(content);      asFile.setFileContent(content);      asFile.setFileName(file.getName());      asFile.setMimeType(MimeMapping.getMimeType(fileName));      DataExchangeListPanel.setProgressText(this.getDataTypeName() + "正在发送文件:" + file.getAbsolutePath());      return this.getBaseDataServiceDelegate().uploadFile(asFile, meta);    } catch (Exception e) {      e.printStackTrace();      return "";    } finally {      if (fis != null) {        try {          fis.close();        } catch (IOException e) {          e.printStackTrace();          return "";        }      }    }  }  /**   * 获得需要导出的数据的所有id，这个id具体对应的id字段是往redo表中插入时   * 保存的，特别的，如果是主子表的，id间用@符号分割。   * @return   */  protected List<String> getNeedExportDataIDList() {    List<String> idList = new ArrayList<String>();    for (int i = 0; i < this.getNeedExportDataRedoList().size(); i++) {      idList.add(this.getNeedExportDataRedoList().get(i).getRecordID());    }    return idList;  }  protected List<DataExchangeRedo> getNeedExportDataList() {    List<DataExchangeRedo> idList = new ArrayList<DataExchangeRedo>();    for (int i = 0; i < this.getNeedExportDataRedoList().size(); i++) {      idList.add(this.getNeedExportDataRedoList().get(i));    }    return idList;  }  public int doModifyDataStatus(ElementConditionDto dto, RequestMeta meta, String standby) {    int count = 0;    Iterator<String> it = this.successRecordMap.keySet().iterator();    while (it.hasNext()) {      DataExchangeRedo redo = this.successRecordMap.get(it.next());      if (!"2".equals(redo.getIsExported())) {        redo.setIsExported("1");      }      this.getDataExchangeServiceDelegate().updateDataExchangeRedoIsExported(redo, meta);      count++;    }    return count;  }  protected void downFile(String fileDirName, String zcImpFileBlobid, String zcImpFile, String sn, String path, RequestMeta meta) throws IOException {    AsFile asFile = getBaseDataServiceDelegate().downloadFile(zcImpFileBlobid, meta);    if (asFile != null) {      boolean isSaveAsTable = false;      if (asFile.getFilePath() == null || "".equals(asFile.getFilePath())) {        isSaveAsTable = true;        FileOutputStream out = null;        try {          out = new FileOutputStream(path+zcImpFileBlobid+asFile.getFileName());          out.write(asFile.getFileContent());          out.flush();        } catch (FileNotFoundException e) {          throw e;        } catch (IOException e) {          e.printStackTrace();          throw e;        } finally {          try {            if (out != null)              out.close();          } catch (IOException e) {            e.printStackTrace();                        throw e;          }        }      } else {        ResumeBrokenDownloads downloads = new ResumeBrokenDownloads(zcImpFileBlobid, "", path, WorkEnv.getInstance().getWebRoot());        downloads.downloadFile();      }      Map<String, AttachmentFile> fileDataMap = new HashMap<String, AttachmentFile>();// attachmentDataMap.get(sn);      AttachmentFile attachmentFile = new AttachmentFile();      attachmentFile.setFileID(zcImpFileBlobid);      attachmentFile.setFileName(zcImpFile);      attachmentFile.setFileType("file");      attachmentFile.setTargetFilePath(fileDirName + File.separator + zcImpFileBlobid+asFile.getFileName());      attachmentFile.setSaveAsFileTable(isSaveAsTable);      fileDataMap.put(sn, attachmentFile);      attachmentDataMap.put(sn, fileDataMap);    }  }  protected void toSendFiles(String rootPath, RequestMeta meta) throws IOException {    Collection<Map<String, AttachmentFile>> values = attachmentDataMap.values();    for (Iterator iterator = values.iterator(); iterator.hasNext();) {      Map<String, AttachmentFile> map = (Map<String, AttachmentFile>) iterator.next();      Collection<AttachmentFile> tempValues = map.values();      for (Iterator iterator2 = tempValues.iterator(); iterator2.hasNext();) {        AttachmentFile attachmentFile = (AttachmentFile) iterator2.next();        File file = new File(rootPath + File.separator + attachmentFile.getTargetFilePath());        FileInputStream fis = null;        AsFile asFile = new AsFile();        try {          fis = new FileInputStream(file);          int fileSize = fis.available();          if (!this.checkFileSize(fileSize, attachmentFile.getFileName())) {            return;          }          byte[] content = new byte[fis.available()];          fis.read(content);          asFile.setFileId(attachmentFile.getFileID());          asFile.setFileContent(content);          String fileName=file.getName();          fileName=fileName.replaceAll(attachmentFile.getFileID(), "");          if(fileName.trim().length()==0){            fileName=file.getName();          }          asFile.setFileName(fileName);          String fname = attachmentFile.getFileName();          String[] t = fname.split("\\.");          String ext = "";          if (t.length > 1)            ext = t[t.length - 1];          asFile.setMimeType(MimeMapping.getMimeType(ext.toLowerCase()));          DataExchangeListPanel.setProgressText(this.getDataTypeName() + "正在发送文件:" + file.getAbsolutePath());        } catch (IOException e) {         throw e;        } finally {          if (fis != null) {            try {              fis.close();            } catch (IOException e) {              e.printStackTrace();              return;            }          }        }        if (attachmentFile.isSaveAsFileTable()) {          getBaseDataServiceDelegate().uploadFile(asFile, meta);        } else {          getBaseDataServiceDelegate().uploadFileSavePath(asFile, meta);        }      }    }  }  /**   * 将AsFile表中得到的小文件保存到本地   * @param buff   * @param localFilePath   */  public void doWriteLittleFileToLocal(byte[] buff, String localFilePath) {    FileOutputStream out = null;    try {      boolean isOK = toCheckAndCreateFileIfNeed(localFilePath, true);      if (!isOK) {        return;      }      out = new FileOutputStream(localFilePath);    } catch (FileNotFoundException e) {      e.printStackTrace();    }    try {      out.write(buff);    } catch (IOException e) {      e.printStackTrace();    }    try {      out.close();    } catch (IOException e) {      e.printStackTrace();    }  }  public boolean toCheckAndCreateFileIfNeed(String fullPath, boolean isAutoCreate) {    File file = new File(fullPath);    if (file.exists()) {      return true;    } else {      if (!isAutoCreate) {        return false;      }      file.getParentFile().mkdirs();      try {        return file.createNewFile();      } catch (Exception e) {        e.printStackTrace();        return false;      }    }  }  /**   * 清除数组中空的部分   * @return   */  public int doClearNullObject() {    int clearCount = 0;    for (int i = 0; i < this.getDataList().size(); i++) {      Object obj = this.getDataList().get(i);      if (obj == null) {        this.getDataList().remove(i);        i--;        clearCount++;      }    }    return clearCount;  }  public byte[] getFileContent(String filePath) throws Exception {    byte[] buff = null;    File file = new File(filePath);    if (file.exists() && file.isFile()) {      buff = new byte[(int) (new File(filePath)).length()];      try {        FileInputStream fis = new FileInputStream(filePath);        int len = fis.read(buff);      } catch (Exception e) {        e.printStackTrace();        throw new Exception("读取文件:" + filePath + "时出错..." + e.getMessage());      }    }    return buff;  }  /**   * 将本地的小文件上传到数据库As_File表中   * @param asFile   * @param rootPath   */  public void doSendLittleFileToServerAsFileTable(AsFile asFile, String rootPath, RequestMeta meta) throws Exception {    if (asFile == null) {      return;    }    asFile.setFileContent(this.getFileContent(rootPath + File.separator + asFile.getFileId()));    this.getBaseDataServiceDelegate().uploadFile(asFile, meta);  }  public abstract int doExportData(ElementConditionDto dto, RequestMeta meta, String saveRootPath);  public abstract int doImportData(ElementConditionDto dto, RequestMeta meta, String readRootPath);  public abstract Map<String, Map<String, AttachmentFile>> getAttachmentDataMap();}