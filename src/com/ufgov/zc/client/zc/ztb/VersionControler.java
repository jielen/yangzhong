package com.ufgov.zc.client.zc.ztb;import com.ufgov.zc.client.zc.ztb.util.DESEncodeAndDecode;import com.ufgov.zc.client.zc.ztb.util.GV;import com.ufgov.zc.common.system.constants.ZcSettingConstants;import java.text.SimpleDateFormat;import java.util.Date;import java.util.HashMap;import java.util.Iterator;import java.util.Map;/** * 版本检查、控制功能类 * * @author LEO */public class VersionControler {  private String zbVersionNO = null;  private String tbVersionNO = null;  private String copyRight = null;  private Map<String, String> hashMap = new HashMap<String, String>();;  private RWConfigInfo rwci = new RWConfigInfo();  public void init() {    this.readDefaultSoftConfigInfo();  }  public Map<String, String> readSoftConfigInfo(String configFilePath) {    RWConfigInfo rci = null;    if (configFilePath == null || "".equals(configFilePath)) {      rci = new RWConfigInfo();    } else {      rci = new RWConfigInfo(configFilePath);    }    this.hashMap.clear();    this.hashMap = rci.readcfg();    P.p("读取到的软件信息如下：");    P.pm(this.hashMap);    return this.hashMap;  }  public Map<String, String> readDefaultSoftConfigInfo() {    this.hashMap.clear();    this.hashMap = rwci.readcfg();    P.p("读取到的缺省软件信息如下：");    P.pm(this.hashMap);    return this.hashMap;  }  public Map<String, String> readDefaultSoftConfigInfoAfterDecoded() throws Exception {    this.readDefaultSoftConfigInfo();    Map<String, String> map = new HashMap<String, String>();    map.put("info", DESEncodeAndDecode.decryptBASE64s(this.hashMap.get("info")));    P.p("解密后读取到的软件信息如下：");    P.pm(map);    return map;  }  /**   * @return   */  public String getDefaultSoftConfigInfoString() {    StringBuffer buff = new StringBuffer();    Map<String, String> infoMap = this.readDefaultSoftConfigInfo();    Iterator<String> it = infoMap.keySet().iterator();    while (it.hasNext()) {      String key = it.next();      buff.append(key);      buff.append(":");      buff.append(infoMap.get(key));      buff.append("@;@");    }    return buff.toString();  }  /**   * @return   */  public String getSoftConfigInfoStringAfterEncoded(String softInfo) throws Exception {    P.p("获得软件缺省配置信息...." + softInfo);    return DESEncodeAndDecode.encryptBASE64(softInfo);  }  /**   * @return   */  public String getDefaultSoftConfigInfoStringAfterEncoded() throws Exception {    P.p("获得软件缺省配置信息....");    return DESEncodeAndDecode.encryptBASE64(this.getDefaultSoftConfigInfoString());  }  /**   * 解释拼接出来的软件信息串   *   * @param infoStr   * @return   */  public Map<String, String> explainSoftConfigInfo(String infoStr) {    this.hashMap.clear();    if (infoStr == null || "".equals(infoStr)) {      return this.hashMap;    }    String[] infos = infoStr.split("@;@");    for (int i = 0; i < infos.length; i++) {      String[] item = infos[i].split(":");      this.hashMap.put(item[0], item[1]);    }    return this.hashMap;  }  /**   * 将传入的数字翻译为中文   *   * @param num   * @return   */  public String translateNumToCN(int num) {    switch (num) {    case 1:      return GV.getSimpleMsg("versionControl000");    case -1:      return GV.getSimpleMsg("versionControl001");    case -2:      return GV.getSimpleMsg("versionControl002");    case -3:      return GV.getSimpleMsg("versionControl003");    case 0:      return GV.getSimpleMsg("versionControl004");    }    return GV.getSimpleMsg("versionControl005");  }  /**   * 版本号比较   * <p/>   * 1、如果askVNO为空，直接返回-1；   * <p/>   * 2、如果beVNO为空，直接返回-1；   * <p/>   * 3、如果beVNO和askVNO都不为空，那么进行比较，如果beVNO；   *   * @param beVNO该版本号是投标书制作工具上面的版本号；   * @param askVNO该版本号是电子标书上携带的版本号，制作招标书时生成；   *   * @return 如果返回1表示通过，返回其它值时表示不通过，例如：   *         <p/>   *         a、返回-1时表示制作工具版本号为空；   *         <p/>   *         b、返回-2时表示电子标书版本号为空；   *         <p/>   *         c、返回0时表示制作工具版本号太低，即beVNO<askVNO；   *         <p/>   *         d、返回-3时表示版本号解密出错，提示版本检测异常；   *         <p/>   *         e、返回1时表示版本校验通过；   *         <p/>   *         具体的翻译见当前类中的translateNumToCN方法；   */  public int versionComparor(String askVNO, String beVNO, boolean isEncoded) {    P.p("beVNO:" + beVNO + ",askVNO:" + askVNO);    if (beVNO == null || "".equals(beVNO)) {      return -1;    }    if (askVNO == null || "".equals(askVNO)) {      return -2;    }    String decodedBeVNO = "";    String decodedAskVNO = "";    if (isEncoded) {      try {        decodedBeVNO = DESEncodeAndDecode.decryptBASE64s(beVNO);        decodedAskVNO = DESEncodeAndDecode.decryptBASE64s(askVNO);      } catch (Exception e) {        e.printStackTrace();        return -3;      }    } else {      decodedBeVNO = beVNO;      decodedAskVNO = askVNO;    }    P.p("decodedBeVNO:" + decodedBeVNO + ",decodedAskVNO:" + decodedAskVNO);    int beVNum = 0;    int askVNum = 0;    String[] v1 = decodedBeVNO.split("\\.");    String[] v2 = decodedAskVNO.split("\\.");    for (int i = 0; i < v1.length; i++) {      int curr = 1;      for (int j = 0; j < v1.length - i - 1; j++) {        curr *= 10;      }      curr = curr * Integer.parseInt(v1[i]);      beVNum += curr;    }    for (int i = 0; i < v2.length; i++) {      int curr = 1;      for (int j = 0; j < v2.length - i - 1; j++) {        curr *= 10;      }      curr = curr * Integer.parseInt(v2[i]);      askVNum += curr;    }    P.p("beVNum:" + beVNum);    P.p("askVNum:" + askVNum);    if (beVNum >= askVNum) {      P.p("版本校验成功通过...");      return 1;    } else {      P.p("版本校验不通过...");      return 0;    }  }  /**   * 每次发布新版本时，修改一下这个版本号，然后运行一下，再打jar包，   * <p/>   * 然后把正式库里面的As_option表中的版本号修改一下,该记录的opt_id   * <p/>   * 为'ZC_EB_ZTB_FILE_ASKFOR_SOFTINFO'，version:1.2.0@;@year:2011@;@month:05@;@date:28   */  public void ToWriteSoftInfo() throws Exception {    Map<String, String> map = new HashMap<String, String>();    map.put("version", "1.4.2");    SimpleDateFormat sdf = new SimpleDateFormat(ZcSettingConstants.SIMPLE_DATE_FORMAT_DATE_ONLY);    String[] today = sdf.format(new Date()).split("-");    map.put("year", today[0]);    map.put("month", today[1]);    map.put("date", today[2]);    P.p("将写入以下信息：");    P.pm(map);    rwci.doWriteConfig(map);  }  public String getZbVersionNO() {    return zbVersionNO;  }  public void setZbVersionNO(String zbVersionNO) {    this.zbVersionNO = zbVersionNO;  }  public String getTbVersionNO() {    return tbVersionNO;  }  public void setTbVersionNO(String tbVersionNO) {    this.tbVersionNO = tbVersionNO;  }  public String getCopyRight() {    return copyRight;  }  public void setCopyRight(String copyRight) {    this.copyRight = copyRight;  }  /**   * @param args   */  public static void main(String[] args) {    //testEncode();    updateSoftInfoToNewVersion();  }  public static void testEncode() {    VersionControler vc = new VersionControler();    try {      String v1 = DESEncodeAndDecode.encryptBASE64("1.2.0");      String v2 = DESEncodeAndDecode.encryptBASE64("1.2.1");      P.p("v1(1.2.0):" + v1 + ",v2(1.2.1):" + v2);      vc.versionComparor(v1, v2, true);    } catch (Exception e) {      e.printStackTrace();    }  }  /**   * 更新软件的版本信息   */  public static void updateSoftInfoToNewVersion() {    VersionControler vc = new VersionControler();    try {      vc.ToWriteSoftInfo();    } catch (Exception e) {      e.printStackTrace();    }  }}