package com.ufgov.zc.client.zc.ztb.service;import java.io.File;import java.util.ArrayList;import java.util.List;import com.ufgov.zc.client.zc.ztb.component.MainPanel;import com.ufgov.zc.client.zc.ztb.component.SingleSeletionTree;import com.ufgov.zc.client.zc.ztb.component.TTBPanel;import com.ufgov.zc.client.zc.ztb.dao.ReadObjectFileToObjectDao;import com.ufgov.zc.client.zc.ztb.model.ResponsePoint;import com.ufgov.zc.client.zc.ztb.model.SmartTreeNode;import com.ufgov.zc.client.zc.ztb.util.GV;import com.ufgov.zc.client.zc.ztb.util.PubFunction;public class InitZtbTreeService {  private ReadObjectFileToObjectDao readTbFileDao = ReadObjectFileToObjectDao.getInstance();  public InitZtbTreeService() {  }  public SingleSeletionTree createFilesTreePanel(MainPanel mp) throws Exception {    if (mp instanceof TTBPanel) {      return new SingleSeletionTree(new SmartTreeNode(), mp);    }    return new SingleSeletionTree(readTbFileDao.readTreeNodes(), mp);  }  /**   * 创建响应点节点树，基本思路：   * <p/>   * 初始创建和编辑过程中，将响应点   * <p/>   * 1、第一次创建时，自动到每个标段下去读取对应标段下的配置文件；   * <p/>   * 2、将这些配置文件生成的节点树合并到一个节点下以显示；   * <p/>   * 3、当在一个标段下添加响应点时，在点击保存时候，将该新增节点保存到对应的节点下；   *   * @param mp   * @param packNode   * @return   * @throws Exception   */  public SingleSeletionTree createPointsTreePanel(MainPanel mp, SmartTreeNode packNode) throws Exception {    if (mp instanceof TTBPanel) {      return new SingleSeletionTree(new SmartTreeNode(), mp);    }    SmartTreeNode rootNode = getRootNode();    List<SmartTreeNode> plist = new ArrayList<SmartTreeNode>();    PubFunction.doSearchAllMatchingNeedingNodeFromCurrNode((SmartTreeNode) packNode.getParent(), "nodeType", GV.NODE_TYPE_PACK, false, 3, plist);    for (int i = 0; i < plist.size(); i++) {      SmartTreeNode retNodes = null;      String xmlPath = toGetXmlPath(plist.get(i), GV.NODE_NAME_RP_TREE);      File xmlFile = new File(xmlPath);      if (xmlFile.isFile() && xmlFile.exists()) {        retNodes = readTbFileDao.readTreeNodes(xmlPath);      } else {        retNodes = toMakeTreeNodes(plist.get(i));      }      PubFunction.checkAndCreateDirOrFile(xmlPath, "F", true, false, retNodes);      rootNode.add(retNodes);    }    return new SingleSeletionTree(rootNode, mp);  }  public SmartTreeNode getRootNode() {    SmartTreeNode rootNode = new SmartTreeNode();    rootNode.setNodeCode("000000");    rootNode.setNodeDisplayName("响应点根节点");    rootNode.setNodeDirPath("");    rootNode.setNodeType("RP_ROOT");    return rootNode;  }  public String toGetXmlPath(SmartTreeNode packNode, String nodeName) {    return GV.getImportFileDir_FromRoot().append(packNode.getNodesFullPath()).append(File.separator).append(nodeName).append(GV.SUFFIX_XML)      .toString();  }  public SmartTreeNode toMakeTreeNodes(SmartTreeNode packNode) throws Exception {    SmartTreeNode rootNode = new SmartTreeNode();    rootNode.setNodeCode(packNode.getNodeCode());    rootNode.setNodeName(packNode.getNodeName() + "响应点");    rootNode.setNodeType(GV.NODE_TYPE_PACK_RP);    rootNode.setNodeDisplayName(packNode.getNodeDisplayName() + "响应点");    StringBuffer buff = new StringBuffer();    buff.append(packNode.getNodesFullPath()).append(File.separator).append(GV.NODE_NAME_RP_TREE).append(GV.SUFFIX_XML).toString();    rootNode.setForExtention3(buff.toString());    String fullPath = toGetXmlPath(packNode, GV.NODE_NAME_RESPONSE_POINT);    List<ResponsePoint> list = readTbFileDao.readListNodes(fullPath);    for (int i = 0; i < list.size(); i++) {      ResponsePoint rp = list.get(i);      SmartTreeNode currNode = new SmartTreeNode();      currNode.setNodeCode(rp.getPointID());      currNode.setNodeName(rp.getPointMemo());      currNode.setNodeType(GV.NODE_TYPE_RESPONSE_POINT);      currNode.setNodeDisplayName(rp.getPointMemo());      currNode.setNodeMemo(rp.getPointMemo());      currNode.setNodeDirPath(rp.getPointTargerPath());      currNode.setForExtention3(rp.getPointTargerContent());      //currNode.setUserObject(rp);      rootNode.add(currNode);    }    return rootNode;  }}