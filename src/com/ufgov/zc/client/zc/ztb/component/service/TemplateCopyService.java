package com.ufgov.zc.client.zc.ztb.component.service;import com.ufgov.zc.client.zc.ztb.model.SimpleTemplateFileModel;import com.ufgov.zc.client.zc.ztb.model.SmartTreeNode;import com.ufgov.zc.client.zc.ztb.util.GV;import com.ufgov.zc.client.zc.ztb.util.PubFunction;import java.io.File;import java.util.ArrayList;import java.util.List;public class TemplateCopyService {  /**   * 拷贝模板到项目分包下，拷贝完毕后，根据目录结构来构建新的配置文件   *   * @param tplFullPath   */  public static boolean doCopyTemplateFilesToProjPack(String tplFullPath, SmartTreeNode packNode, boolean needDeletetempXml) {    //同类模板很多 需要添加多个文件夹    String sourcePath = tplFullPath;    String targetPath = GV.getImportFileDir_FromRoot().append(packNode.getNodesFullPath()).toString();    doCopyTemplateFiles(sourcePath, targetPath, needDeletetempXml);    buildTreeNodeByDirectoryStruct(targetPath, packNode);    return true;  }  /**   * 拷贝模板到项目分包下，拷贝完毕后，根据目录结构来构建新的配置文件   *   * @param tplFullPath   */  public static boolean doCopyTemplateFiles(String sourcePath, String targetPath, boolean needDeletetempXml) {    PubFunction.deleteFile(new File(targetPath));    try {      PubFunction.copyFiles(sourcePath, targetPath);      String filePath = targetPath + File.separator + GV.TEMPLATE_CONFIG_XML;      File file = new File(filePath);      if (needDeletetempXml && file != null) {        file.delete();      }    } catch (Exception e) {      e.printStackTrace();      return false;    }    return true;  }  /**   * 拷贝完成模板文件到项目分包后，根据当前分包下的文件重构树节点   *   * @param packPath   * @param packNode   */  private static void buildTreeNodeByDirectoryStruct(String packPath, SmartTreeNode packNode) {    File packDir = new File(packPath);    File[] files = packDir.listFiles();    SmartTreeNode bNode = null;    packNode.removeAllChildren();    if (packDir.exists() && files != null) {      for (int i = 0; i < files.length; i++) {        if (files[i].getName().startsWith("~$") || files[i].getName().startsWith("~")) {//针对word临时文档或文件夹进行忽略处理          continue;        }        if (files[i].isDirectory() && GV.NODE_NAME_BUSINESS.equals(files[i].getName())) {          bNode = new SmartTreeNode();          packNode.add(bNode);          bNode.setNodeCode(GV.NODE_CODE_BUSINESS + SmartTreeNode.SMART_TREE_NODE_COUNT);          bNode.setNodeDirPath(GV.NODE_NAME_BUSINESS);          bNode.setNodeType(GV.NODE_TYPE_PACK_BUSINESS);          bNode.setNodeDisplayName(GV.NODE_NAME_BUSINESS);          bNode.setNodeSource(GV.NODE_SOURCE_FROM_MOLD);          bNode.setNodeName(GV.NODE_NAME_BUSINESS);          bNode.setNodeSequance(i);          makeBusinessNodes(bNode, getFileList(packPath + File.separator + GV.NODE_NAME_BUSINESS));        } else if (files[i].isDirectory() && GV.NODE_NAME_TECH.equals(files[i].getName())) {          bNode = new SmartTreeNode();          packNode.add(bNode);          bNode.setNodeCode(GV.NODE_CODE_TECH + SmartTreeNode.SMART_TREE_NODE_COUNT);          bNode.setNodeDirPath(GV.NODE_NAME_TECH);          bNode.setNodeType(GV.NODE_TYPE_PACK_TECH);          bNode.setNodeDisplayName(GV.NODE_NAME_TECH);          bNode.setNodeName(GV.NODE_NAME_TECH);          bNode.setNodeSource(GV.NODE_SOURCE_FROM_MOLD);          bNode.setNodeSequance(i);          makeTechnicalNodes(bNode, getFileList(packPath + File.separator + GV.NODE_NAME_TECH));        } else if (files[i].isDirectory() && GV.NODE_NAME_ZB.indexOf(files[i].getName()) != -1) {          String fileName = files[i].getName();          bNode = new SmartTreeNode();          packNode.add(bNode);          bNode.setNodeCode(GV.NODE_CODE_ZB + SmartTreeNode.SMART_TREE_NODE_COUNT);          bNode.setNodeDirPath(fileName);          bNode.setNodeType(GV.NODE_TYPE_ZB);          bNode.setNodeDisplayName(fileName);          bNode.setNodeName(fileName);          bNode.setNodeSource(GV.NODE_SOURCE_FROM_MOLD);          bNode.setNodeSequance(i);          makeCommonNodes(bNode, getFileList(packPath + File.separator + fileName));        } else if (files[i].isDirectory() && GV.NODE_NAME_TB.indexOf(files[i].getName()) != -1) {          String fileName = files[i].getName();          bNode = new SmartTreeNode();          packNode.add(bNode);          bNode.setNodeCode(GV.NODE_CODE_TB + SmartTreeNode.SMART_TREE_NODE_COUNT);          bNode.setNodeDirPath(fileName);          bNode.setNodeType(GV.NODE_TYPE_TB);          bNode.setNodeDisplayName(fileName);          bNode.setNodeName(fileName);          bNode.setNodeSource(GV.NODE_SOURCE_FROM_MOLD);          bNode.setNodeSequance(i);          makeCommonNodes(bNode, getFileList(packPath + File.separator + fileName));        } else if (files[i].isDirectory() && (GV.NODE_NAME_ZBTB.indexOf(files[0].getName()) == -1)) {          String fileName = files[i].getName();          bNode = new SmartTreeNode();          packNode.add(bNode);          bNode.setNodeCode(GV.NODE_CODE_OTHER + SmartTreeNode.SMART_TREE_NODE_COUNT);          bNode.setNodeDirPath(fileName);          bNode.setNodeType(GV.NODE_TYPE_DIR);          bNode.setNodeDisplayName(fileName);          bNode.setNodeName(fileName);          bNode.setNodeSource(GV.NODE_SOURCE_FROM_MOLD);          bNode.setNodeSequance(i);          makeCommonNodes(bNode, getFileList(packPath + File.separator + fileName));        } else if (files[i].isDirectory()) {          String fileName = files[i].getName();          bNode = new SmartTreeNode();          packNode.add(bNode);          bNode.setNodeCode(GV.NODE_CODE_OTHER + SmartTreeNode.SMART_TREE_NODE_COUNT);          bNode.setNodeDirPath(fileName);          bNode.setNodeType(GV.NODE_TYPE_DIR);          bNode.setNodeDisplayName(fileName);          bNode.setNodeName(fileName);          bNode.setNodeSource(GV.NODE_SOURCE_FROM_MOLD);          bNode.setNodeSequance(i);          makeCommonNodes(bNode, getFileList(packPath + File.separator + fileName));        } else if (files[i].isFile()) {          String fileName = files[i].getName().toLowerCase();          String type = GV.getTypeByExt(fileName.substring(fileName.lastIndexOf(".")));          if (type == null || "".equals(type) || fileName.endsWith(GV.SUFFIX_TABLE_SETTING)) {            continue;          }          bNode = new SmartTreeNode();          bNode.setNodeType(type);          bNode.setAllowsChildren(false);          bNode.setNodeCode(GV.NODE_CODE_OTHER + SmartTreeNode.SMART_TREE_NODE_COUNT);          bNode.setNodeDirPath(fileName);          bNode.setNodeDisplayName(fileName.substring(0, fileName.lastIndexOf(".")));          bNode.setNodeName(fileName.substring(0, fileName.lastIndexOf(".")));          bNode.setNodeSource(GV.NODE_SOURCE_FROM_MOLD);          bNode.setFileExtension(fileName.substring(fileName.lastIndexOf("."), fileName.length()));          bNode.setNodeSequance(i);          packNode.add(bNode);        }      }    }  }  /**   * 读取模板文件，根据结构来生成模板数据结构   *   * @param path   * @return   */  private static List<SimpleTemplateFileModel> getFileList(String path) {    List<SimpleTemplateFileModel> list = new ArrayList<SimpleTemplateFileModel>();    File file = new File(path);    File[] files = file.listFiles();    SimpleTemplateFileModel tpl = null;    String fileName = null;    if (files != null) {      for (int i = 0; i < files.length; i++) {        tpl = new SimpleTemplateFileModel();        if (files[i].isDirectory()) {          tpl.setSubFileList(getFileList(files[i].getAbsolutePath()));        }        fileName = files[i].getName();        if (-1 != fileName.toLowerCase().indexOf(GV.SUFFIX_TABLE_SETTING)) {          continue;        }        tpl.setEditable(true);        if (fileName.indexOf(".") != -1 && files[i].isFile()) {          tpl.setFileChName(fileName.substring(0, fileName.lastIndexOf(".")));          tpl.setFileExtension(fileName.substring(fileName.lastIndexOf("."), fileName.length()));        } else {          tpl.setFileChName(fileName);          tpl.setFileExtension("DIR");        }        tpl.setFileName(tpl.getFileChName());        tpl.setFileType(GV.getTypeByExt(tpl.getFileExtension()));        if (fileName.indexOf(GV.NODE_NAME_TBYLB) != -1 && files[i].isFile() && fileName.endsWith(GV.SUFFIX_TABLE)) {          tpl.setFileType(GV.NODE_TYPE_TBYLB);        }        list.add(tpl);      }    }    return list;  }  public static void makeBusinessNodes(SmartTreeNode businessNode, List<SimpleTemplateFileModel> fileList) {    SmartTreeNode node = null;    SimpleTemplateFileModel temp = null;    for (int i = 0; i < fileList.size(); i++) {      temp = fileList.get(i);      node = new SmartTreeNode();      businessNode.add(node);      node.setNodeCode(GV.NODE_CODE_BUSINESS + SmartTreeNode.SMART_TREE_NODE_COUNT);      node.setNodeName(temp.getFileName());      node.setNodeType(temp.getFileType());      node.setNodeDirPath(temp.getFileName());      node.setNodeDisplayName(temp.getFileChName());      node.setFileExtension(temp.getFileExtension());      node.setNodeSource(GV.NODE_SOURCE_FROM_MOLD);      node.setNodeSequance(i);      node.setLocked(false);      List<SimpleTemplateFileModel> list = temp.getSubFileList();      if (list != null && list.size() > 0) {        node.setAllowsChildren(true);        makeBusinessNodes(node, list);      } else {        node.setAllowsChildren(false);      }    }  }  public static void makeTechnicalNodes(SmartTreeNode techNode, List<SimpleTemplateFileModel> fileList) {    SmartTreeNode node = null;    SimpleTemplateFileModel temp = null;    for (int i = 0; i < fileList.size(); i++) {      temp = fileList.get(i);      if (GV.SUFFIX_TABLE_SETTING.equalsIgnoreCase(temp.getFileExtension())) {        continue;      }      node = new SmartTreeNode();      techNode.add(node);      node.setNodeCode(GV.NODE_CODE_TECH + SmartTreeNode.SMART_TREE_NODE_COUNT);      node.setNodeName(temp.getFileName());      node.setNodeDisplayName(temp.getFileName());      node.setNodeType(temp.getFileType());      node.setNodeDirPath(temp.getFileName());      node.setNodeSource(GV.NODE_SOURCE_FROM_MOLD);      node.setFileExtension(temp.getFileExtension());      node.setNodeSequance(i);      node.setLocked(false);      List<SimpleTemplateFileModel> list = temp.getSubFileList();      if (list != null && list.size() > 0) {        node.setAllowsChildren(true);        makeTechnicalNodes(node, list);      } else {        node.setAllowsChildren(false);      }    }  }  public static void makeCommonNodes(SmartTreeNode pNode, List<SimpleTemplateFileModel> fileList) {    SmartTreeNode node = null;    SimpleTemplateFileModel temp = null;    for (int i = 0; i < fileList.size(); i++) {      temp = fileList.get(i);      if (GV.SUFFIX_TABLE_SETTING.equalsIgnoreCase(temp.getFileExtension())) {        continue;      }      node = new SmartTreeNode();      pNode.add(node);      node.setNodeCode(pNode.getNodeCode() + SmartTreeNode.SMART_TREE_NODE_COUNT);      node.setNodeName(temp.getFileName());      node.setNodeDisplayName(temp.getFileName());      node.setNodeType(temp.getFileType());      node.setNodeDirPath(temp.getFileName());      node.setNodeSource(GV.NODE_SOURCE_FROM_MOLD);      node.setFileExtension(temp.getFileExtension());      node.setNodeSequance(i);      node.setLocked(false);      List<SimpleTemplateFileModel> list = temp.getSubFileList();      if (list != null && list.size() > 0) {        node.setAllowsChildren(true);        makeCommonNodes(node, list);      } else {        node.setAllowsChildren(false);      }    }  }}