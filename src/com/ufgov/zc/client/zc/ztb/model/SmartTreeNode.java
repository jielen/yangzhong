package com.ufgov.zc.client.zc.ztb.model;import com.ufgov.zc.client.zc.ztb.model.face.ISmartUserObject;import com.ufgov.zc.client.zc.ztb.util.GV;import com.ufgov.zc.client.zc.ztb.util.Guid;import com.ufgov.zc.client.zc.ztb.util.PubFunction;import javax.swing.tree.DefaultMutableTreeNode;import javax.swing.tree.TreeNode;import java.io.File;import java.util.Enumeration;public class SmartTreeNode extends DefaultMutableTreeNode implements Cloneable {  private static final long serialVersionUID = -8184626129106817806L;  public static int SMART_TREE_NODE_COUNT = 0;  protected boolean isVisible = true;  private String nodeGUID = Guid.genID();  private String nodeCode = GV.NODE_CODE_ROOT;  private String nodeName = "projList";  private String nodeDisplayName = "项目列表";  private String nodeType = GV.NODE_TYPE_ROOT;  private String nodeMemo = "";  /**   * 当前节点及节点父节点的全路径   */  private String nodesFullPath = null;  /**   * 当前节点目录路径名称，一般和code相同   */  private String nodeDirPath = "";  private boolean isShowUserObjectInfo = true;  private boolean isLocked = false;  /**   * 如果当前节点为文件的话，则需要该节点的扩展名称   */  private String fileExtension = null;  /**   * 节点下的数据是否自动加载，false的话会在该节点展开的时候加载。   */  private boolean isAutoToLoad = true;  /**   * 设置是否在投标和招标文件中都显示   *   * @param value值为TB时表示只在招标文件制作器中显示，   * <p/>   * value值为ZB时，表示只在招标文件中显示，   * <p/>   * value值为BOTH时，表示两种情况下都显示；   * @return   */  private String displayType;  private boolean renameable = false;  //节点来源：10为自己创建、20为来自项目、30为来自模板、100为其它  private int nodeSource = 10;  private int nodeSequance = 0;  //节点是否处于展开状态  private boolean isUnfold = true;  /**   * 为了防止日后更改该对象，定义以下备用字段   */  private int forExtention1;  private int forExtention2;  private String forExtention3;  private String forExtention4;  private String forExtention5;  private boolean isSelected;  public SmartTreeNode() {    this.isVisible = true;    SMART_TREE_NODE_COUNT++;  }  public String getNodeGUID() {    return nodeGUID;  }  public void setNodeGUID(String nodeGUID) {    this.nodeGUID = nodeGUID;  }  public ISmartUserObject getUserObject() {    return (ISmartUserObject) super.getUserObject();  }  public String getNodeCode() {    return nodeCode;  }  public void setNodeCode(String nodeCode) {    this.nodeCode = nodeCode;  }  public String getNodeName() {    return PubFunction.deleteSpecialCode(nodeName);  }  public void setNodeName(String nodeName) {    this.nodeName = PubFunction.deleteSpecialCode(nodeName);  }  public String getNodeType() {    return nodeType;  }  public void setNodeType(String nodeType) {    this.nodeType = nodeType;  }  public String getNodeMemo() {    nodeMemo = nodeName + "【" + nodeCode + "】";    return PubFunction.deleteSpecialCode(nodeMemo);  }  public void setNodeMemo(String nodeMemo) {    this.nodeMemo = PubFunction.deleteSpecialCode(this.nodeMemo);  }  public String getDisplayType() {    return displayType;  }  public void setDisplayType(String displayType) {    this.displayType = displayType;  }  public Object deepClone(SmartTreeNode currentNode) throws CloneNotSupportedException {    SmartTreeNode node = (SmartTreeNode) super.clone();    for (int i = 0; i < getChildCount(); i++) {      SmartTreeNode childNode = (SmartTreeNode) getChildAt(i);      SmartTreeNode newChildNode = (SmartTreeNode) childNode.deepClone(childNode);      node.insert(newChildNode, i);    }    return node;  }  public boolean isShowUserObjectInfo() {    return isShowUserObjectInfo;  }  public void setShowUserObjectInfo(boolean isShowUserObjectInfo) {    this.isShowUserObjectInfo = isShowUserObjectInfo;  }  public boolean isLocked() {    return isLocked;  }  public void setLocked(boolean isLocked) {    this.isLocked = isLocked;  }  public String getFileExtension() {    return fileExtension;  }  public void setFileExtension(String fileExtension) {    this.fileExtension = fileExtension;  }  public boolean isAutoToLoad() {    return isAutoToLoad;  }  public void setAutoToLoad(boolean isAutoToLoad) {    this.isAutoToLoad = isAutoToLoad;  }  /**   * 必须覆盖该方法，方可以使用JTreeCellRenderer类进行树构造时将当前节点的名称显示出来   */  public String toString() {    return this.nodeDisplayName;  }  public String getNodeDirPath() {    return nodeDirPath;  }  public void setNodeDirPath(String nodeDirPath) {    this.nodeDirPath = nodeDirPath;  }  public String getNodeDisplayName() {    return PubFunction.deleteSpecialCode(nodeDisplayName);  }  public void setNodeDisplayName(String nodeDisplayName) {    this.nodeDisplayName = PubFunction.deleteSpecialCode(nodeDisplayName);  }  public String getNodesFullPath() {    if (!this.isRoot()) {      this.nodesFullPath = ((SmartTreeNode) this.getParent()).getNodesFullPath() + File.separator + this.nodeDirPath;    } else {      this.nodesFullPath = this.nodeDirPath;    }    return PubFunction.deleteSpecialCode(nodesFullPath);  }  public String getNodesFullPathWithExtIfExist() {    if (!this.isRoot()) {      this.nodesFullPath = ((SmartTreeNode) this.getParent()).getNodesFullPath() + File.separator + this.nodeDirPath;    } else {      this.nodesFullPath = this.nodeDirPath;    }    if (this.isLeaf()) {      this.nodesFullPath = this.nodesFullPath + this.getFileExtension();    }    return PubFunction.deleteSpecialCode(nodesFullPath);  }  /**   * 获得当前节点的位置   *   * @return   */  public String getNodePositionByDisplayName() {    String pos = null;    if (!this.isRoot()) {      pos = ((SmartTreeNode) this.getParent()).getNodePositionByDisplayName() + File.separator + this.nodeDisplayName;    } else {      pos = this.nodeDisplayName;    }    return PubFunction.deleteSpecialCode(pos);  }  public boolean isRenameable() {    return renameable;  }  public void setRenameable(boolean renameable) {    this.renameable = renameable;  }  public int getNodeSource() {    return nodeSource;  }  public void setNodeSource(int nodeSource) {    this.nodeSource = nodeSource;  }  public int getNodeSequance() {    return nodeSequance;  }  public void setNodeSequance(int nodeSequance) {    this.nodeSequance = nodeSequance;  }  public int getForExtention1() {    return forExtention1;  }  public void setForExtention1(int forExtention1) {    this.forExtention1 = forExtention1;  }  public int getForExtention2() {    return forExtention2;  }  public void setForExtention2(int forExtention2) {    this.forExtention2 = forExtention2;  }  public String getForExtention3() {    return forExtention3;  }  public void setForExtention3(String forExtention3) {    this.forExtention3 = forExtention3;  }  public String getForExtention4() {    return forExtention4;  }  public void setForExtention4(String forExtention4) {    this.forExtention4 = forExtention4;  }  public String getForExtention5() {    return forExtention5;  }  public void setForExtention5(String forExtention5) {    this.forExtention5 = forExtention5;  }  public void setNodesFullPath(String nodesFullPath) {    this.nodesFullPath = nodesFullPath;  }  public boolean isUnfold() {    return isUnfold;  }  public void setUnfold(boolean isUnfold) {    this.isUnfold = isUnfold;  }  public TreeNode getChildAt(int index, boolean filterIsActive) {    if (!filterIsActive) {      return super.getChildAt(index);    }    if (children == null) {      throw new ArrayIndexOutOfBoundsException("node has no children");    }    int realIndex = -1;    int visibleIndex = -1;    Enumeration e = children.elements();    while (e.hasMoreElements()) {      SmartTreeNode node = (SmartTreeNode) e.nextElement();      if (node.isVisible()) {        visibleIndex++;      }      realIndex++;      if (visibleIndex == index) {        return (TreeNode) children.elementAt(realIndex);      }    }    throw new ArrayIndexOutOfBoundsException("index unmatched");    //return (TreeNode)children.elementAt(index);  }  public int getChildCount(boolean filterIsActive) {    if (!filterIsActive) {      return super.getChildCount();    }    if (children == null) {      return 0;    }    int count = 0;    Enumeration e = children.elements();    while (e.hasMoreElements()) {      SmartTreeNode node = (SmartTreeNode) e.nextElement();      if (node.isVisible()) {        count++;      }    }    return count;  }  public void setVisible(boolean visible) {    this.isVisible = visible;  }  public boolean isVisible() {    return isVisible;  }  public boolean isSelected() {    return isSelected;  }  public void setSelected(boolean isSelected) {    this.isSelected = isSelected;  }}